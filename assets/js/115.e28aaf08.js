(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{688:function(e,r,a){"use strict";a.r(r);var t=a(5),o=Object(t.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("最近，confluent社区发表了一篇文章，主要讲述了Kafka未来的2.8版本将要放弃Zookeeper，这对于Kafka用户来说，是一个重要的改进。之前部署Kafka就必须得部署Zookeeper，而之后就只要单独部署Kafka就行了。[1]")]),e._v(" "),a("h2",{attrs:{id:"kafka简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka简介"}},[e._v("#")]),e._v(" Kafka简介")]),e._v(" "),a("p",[e._v("Apache Kafka最早是由Linkedin公司开发，后来捐献给了Apack基金会。")]),e._v(" "),a("p",[e._v("Kafka被官方定义为分布式流式处理平台，因为具备高吞吐、可持久化、可水平扩展等特性而被广泛使用。目前Kafka具体如下功能：")]),e._v(" "),a("ul",[a("li",[e._v("消息队列,Kafka具有系统解耦、流量削峰、缓冲、异步通信等消息队列的功能。")]),e._v(" "),a("li",[e._v("分布式存储系统，Kafka可以把消息持久化，同时用多副本来实现故障转移，可以作为数据存储系统来使用。")]),e._v(" "),a("li",[e._v("实时数据处理，Kafka提供了一些和数据处理相关的组件，比如Kafka Streams、Kafka Connect，具备了实时数据的处理功能。")])]),e._v(" "),a("p",[e._v("下面这张图是Kafka的消息模型：[2]")]),e._v(" "),a("p",[a("img",{attrs:{src:"/8c3ab9af88001949566c76389b3153c7.png-wh_600x-s_230681648.png",alt:"Kafka1"}})]),e._v(" "),a("p",[e._v("通过上面这张图，介绍一下Kafka中的几个主要概念：")]),e._v(" "),a("ul",[a("li",[e._v("producer和consumer: 消息队列中的生产者和消费者，生产者将消息推送到队列，消费者从队列中拉取消息。")]),e._v(" "),a("li",[e._v("consumer group:消费者集合，这些消费者可以并行消费同一个topic下不同partition中的消息。")]),e._v(" "),a("li",[e._v("broker：Kafka集群中的服务器。")]),e._v(" "),a("li",[e._v("topic：消息的分类。")]),e._v(" "),a("li",[e._v("partition：topic物理上的分组，一个topic可以有partition，每个partition中的消息会被分配一个有序的id作为offset。每个consumer group只能有一个消费者来消费一个partition。")])]),e._v(" "),a("h2",{attrs:{id:"kafka和zookeeper关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka和zookeeper关系"}},[e._v("#")]),e._v(" Kafka和Zookeeper关系")]),e._v(" "),a("p",[e._v("Kafka架构如下图：图片从图中可以看到，Kafka的工作需要Zookeeper的配合。那他们到底是怎么配合工作呢?")]),e._v(" "),a("p",[e._v("看下面这张图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"/d6b1845894f2a2ba16afb06984cb45e5.png",alt:"Kafka2"}})]),e._v(" "),a("p",[e._v("从图中可以看到，Kafka的工作需要Zookeeper的配合。那他们到底是怎么配合工作呢？\n看下面这张图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"/73196028cf801ff19ff2ac1afa960c14.png-wh_600x-s_3091085894.png",alt:"Kafka3"}})]),e._v(" "),a("h3",{attrs:{id:"注册中心"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注册中心"}},[e._v("#")]),e._v(" 注册中心")]),e._v(" "),a("h4",{attrs:{id:"broker注册"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#broker注册"}},[e._v("#")]),e._v(" broker注册")]),e._v(" "),a("p",[e._v("从上面的图中可以看到，broker分布式部署，就需要一个注册中心来进行统一管理。Zookeeper用一个专门节点保存Broker服务列表，也就是 /brokers/ids。\nbroker在启动时，向Zookeeper发送注册请求，Zookeeper会在/brokers/ids下创建这个broker节点，如/brokers/ids/[0...N]，并保存broker的IP地址和端口。\n这个节点临时节点，一旦broker宕机，这个临时节点会被自动删除。")]),e._v(" "),a("h4",{attrs:{id:"topic注册"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#topic注册"}},[e._v("#")]),e._v(" topic注册")]),e._v(" "),a("p",[e._v("Zookeeper也会为topic分配一个单独节点，每个topic都会以/brokers/topics/[topic_name]的形式记录在Zookeeper。\n一个topic的消息会被保存到多个partition，这些partition跟broker的对应关系也需要保存到Zookeeper。\npartition是多副本保存的，上图中红色partition是leader副本。当leader副本所在的broker发生故障时，partition需要重新选举leader，这个需要由Zookeeper主导完成。\nbroker启动后，会把自己的Broker ID注册到到对应topic节点的分区列表中。\n我们查看一个topic是xxx，分区编号是1的信息，命令如下：")]),e._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("root@master"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" get /brokers/topics/xxx/partitions/1/state\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"controller_epoch"')]),e._v(":15,"),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"leader"')]),e._v(":11,"),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"version"')]),e._v(":1,"),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"leader_epoch"')]),e._v(":2,"),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"isr"')]),e._v(":"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("11,12")]),e._v(",13"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("当broker退出后，Zookeeper会更新其对应topic的分区列表。")]),e._v(" "),a("h4",{attrs:{id:"consumer注册"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consumer注册"}},[e._v("#")]),e._v(" consumer注册")]),e._v(" "),a("p",[e._v("消费者组也会向Zookeeper进行注册，Zookeeper会为其分配节点来保存相关数据，节点路径为/consumers/{group_id}，有3个子节点，如下图:")]),e._v(" "),a("p",[a("img",{attrs:{src:"/63ab7e224c073c3ac9a391ad68622e75.png-wh_600x-s_1924041234.png",alt:"Kafka4"}})]),e._v(" "),a("p",[e._v("这样Zookeeper可以记录分区跟消费者的关系，以及分区的offset。[3]")]),e._v(" "),a("h3",{attrs:{id:"负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡"}},[e._v("#")]),e._v(" 负载均衡")]),e._v(" "),a("p",[e._v("broker向Zookeeper进行注册后，生产者根据broker节点来感知broker服务列表变化，这样可以实现动态负载均衡。\nconsumer group中的消费者，可以根据topic节点信息来拉取特定分区的消息,实现负载均衡。\n实际上，Kafka在Zookeeper中保存的元数据非常多，看下面这张图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"/01360056c4ebf173e0b63b3c5a77bd71.png-wh_600x-s_3713766394.png",alt:"Kafka5"}})]),e._v(" "),a("p",[e._v("随着broker、topic和partition增多，保存的数据量会越来越大。")]),e._v(" "),a("h2",{attrs:{id:"controller介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#controller介绍"}},[e._v("#")]),e._v(" Controller介绍")]),e._v(" "),a("p",[e._v("经过上一节的讲述，我们看到了Kafka对Zookeeper的依赖非常大，Kafka离开Zookeeper是没有办法独立运行的。那Kafka是怎么跟Zookeeper进行交互的呢?")]),e._v(" "),a("p",[e._v("如下图：[4]Kafka集群中会有一个broker被选举为Controller负责跟Zookeeper进行交互，它负责管理整个Kafka集群中所有分区和副本的状态。其他broker监听Controller节点的数据变化。")]),e._v(" "),a("p",[e._v("Controller的选举工作依赖于Zookeeper，选举成功后，Zookeeper会创建一个/controller临时节点。")]),e._v(" "),a("p",[e._v("Controller具体职责如下：")]),e._v(" "),a("ul",[a("li",[e._v("监听分区变化")])]),e._v(" "),a("p",[e._v("比如当某个分区的leader出现故障时，Controller会为该分区选举新的leader。当检测到分区的ISR集合发生变化时，Controller会通知所有broker更新元数据。当某个topic增加分区时，Controller会负责重新分配分区。")]),e._v(" "),a("ul",[a("li",[e._v("监听topic相关的变化")]),e._v(" "),a("li",[e._v("监听broker相关的变化")]),e._v(" "),a("li",[e._v("集群元数据管理")])]),e._v(" "),a("p",[e._v("下面这张图展示了Controller、Zookeeper和broker的交互细节：")]),e._v(" "),a("p",[a("img",{attrs:{src:"/8c1872cf1934dfa6605c0ac41ee011af.png-wh_600x-s_3619584714.png",alt:"Kafka6"}})]),e._v(" "),a("p",[e._v("Controller选举成功后，会从Zookeeper集群中拉取一份完整的元数据初始化ControllerContext，这些元数据缓存在Controller节点。当集群发生变化时，比如增加topic分区，Controller不仅需要变更本地的缓存数据，还需要将这些变更信息同步到其他Broker。")]),e._v(" "),a("p",[e._v("Controller监听到Zookeeper事件、定时任务事件和其他事件后，将这些事件按照先后顺序暂存到LinkedBlockingQueue中，由事件处理线程按顺序处理，这些处理多数需要跟Zookeeper交互，Controller则需要更新自己的元数据。")]),e._v(" "),a("h2",{attrs:{id:"zookeeper带来的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper带来的问题"}},[e._v("#")]),e._v(" Zookeeper带来的问题")]),e._v(" "),a("p",[e._v("Kafka本身就是一个分布式系统，但是需要另一个分布式系统来管理，复杂性无疑增加了。")]),e._v(" "),a("h3",{attrs:{id:"运维复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运维复杂度"}},[e._v("#")]),e._v(" 运维复杂度")]),e._v(" "),a("p",[e._v("使用了Zookeeper，部署Kafka的时候必须要部署两套系统，Kafka的运维人员必须要具备Zookeeper的运维能力。")]),e._v(" "),a("h3",{attrs:{id:"controller故障处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#controller故障处理"}},[e._v("#")]),e._v(" Controller故障处理")]),e._v(" "),a("p",[e._v("Kafaka依赖一个单一Controller节点跟Zookeeper进行交互，如果这个Controller节点发生了故障，就需要从broker中选择新的Controller。如下图,新的Controller变成了broker3。")]),e._v(" "),a("p",[a("img",{attrs:{src:"/59ea31b7ae4017f29ab6c18b78a234ee.jpg-wh_600x-s_961669565.jpg",alt:"Kafka6"}})]),e._v(" "),a("p",[e._v("新的Controller选举成功后，会重新从Zookeeper拉取元数据进行初始化，并且需要通知其他所有的broker更新ActiveControllerId。老的Controller需要关闭监听、事件处理线程和定时任务。分区数非常多时，这个过程非常耗时，而且这个过程中Kafka集群是不能工作的。")]),e._v(" "),a("h3",{attrs:{id:"分区瓶颈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分区瓶颈"}},[e._v("#")]),e._v(" 分区瓶颈")]),e._v(" "),a("p",[e._v("当分区数增加时，Zookeeper保存的元数据变多，Zookeeper集群压力变大，达到一定级别后，监听延迟增加，给Kafaka的工作带来了影响。")]),e._v(" "),a("p",[e._v("所以，Kafka单集群承载的分区数量是一个瓶颈。而这又恰恰是一些业务场景需要的。")]),e._v(" "),a("h2",{attrs:{id:"升级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#升级"}},[e._v("#")]),e._v(" 升级")]),e._v(" "),a("p",[e._v("升级前后的架构图对比如下：")]),e._v(" "),a("p",[a("img",{attrs:{src:"/af8a6e2527cc126816713c84a4f46fa5.png",alt:"Kafka7"}})]),e._v(" "),a("p",[e._v("KIP-500用Quorum Controller代替之前的Controller，Quorum中每个Controller节点都会保存所有元数据，通过KRaft协议保证副本的一致性。这样即使Quorum Controller节点出故障了，新的Controller迁移也会非常快。\n官方介绍，升级之后，Kafka可以轻松支持百万级别的分区。\nKafak团队把通过Raft协议同步数据的方式Kafka Raft Metadata mode,简称KRaft\nKafka的用户体量非常大，在不停服的情况下升级是必要的。\n目前去除Zookeeper的Kafka代码KIP-500已经提交到trunk分支，并且计划在未来的2.8版本发布。\nKafaka计划在3.0版本会兼容Zookeeper Controller和Quorum Controller，这样用户可以进行灰度测试。[5]")]),e._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[e._v("在大规模集群和云原生的背景下，使用Zookeeper给Kafka的运维和集群性能造成了很大的压力。去除Zookeeper是必然趋势，这也符合大道至简的架构思想。")]),e._v(" "),a("p",[e._v("Reference")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("[1]参考1: "),a("a",{attrs:{href:"https://www.confluent.io/blog/kafka-without-zookeeper-a-sneak-peek/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apache Kafka Made Simple: A First Glimpse of a Kafka Without ZooKeeper"),a("OutboundLink")],1)])]),e._v(" "),a("li",[a("p",[e._v("[2]参考2: "),a("a",{attrs:{href:"https://blog.csdn.net/Zidingyi_367/article/details/110490910",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kafka Controller工作原理"),a("OutboundLink")],1)])]),e._v(" "),a("li",[a("p",[e._v("[3]参考3: "),a("a",{attrs:{href:"https://www.jianshu.com/p/a036405f989c",target:"_blank",rel:"noopener noreferrer"}},[e._v("Zookeeper 在 Kafka 中的作用"),a("OutboundLink")],1)])]),e._v(" "),a("li",[a("p",[e._v("[4]参考4: "),a("a",{attrs:{href:"https://honeypps.com/mq/kafka-controller-analysis/",target:"_blank",rel:"noopener noreferrer"}},[e._v("直击Kafka的心脏——控制器"),a("OutboundLink")],1)])]),e._v(" "),a("li",[a("p",[e._v("[5]参考5: "),a("a",{attrs:{href:"https://mp.weixin.qq.com/s/ev6NM6hptltQBuTaCHJCQQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("消息系统兴起二次革命：Kafka不需要ZooKeeper"),a("OutboundLink")],1)])])])])}),[],!1,null,null,null);r.default=o.exports}}]);