(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{725:function(r,t,e){"use strict";e.r(t);var a=e(5),v=Object(a.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("p",[r._v("Web UI项目中, 很多 Spring controller 视图函数直接返回 html 页面, 还有一些视图函数是要重定向或转发到其他的 url 上.")]),r._v(" "),e("h2",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[r._v("#")]),r._v(" 定义")]),r._v(" "),e("h3",{attrs:{id:"请求转发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求转发"}},[r._v("#")]),r._v(" 请求转发")]),r._v(" "),e("p",[r._v("浏览器向服务器发起仅一次请求、\n服务器可以多次转发这个请求，寻找同一web程序下的资源\n然后将结果返回给浏览器")]),r._v(" "),e("h3",{attrs:{id:"举例说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#举例说明"}},[r._v("#")]),r._v(" 举例说明")]),r._v(" "),e("p",[r._v("劫匪朝要张三100W（request），\n不管他是朝几个人、怎么借的、（内部多次转发）\n打钱给劫匪（response）\n但张三只能是朝自己认识的人借钱（调用你认识的人、内部资源）")]),r._v(" "),e("h3",{attrs:{id:"重定向"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重定向"}},[r._v("#")]),r._v(" 重定向")]),r._v(" "),e("p",[r._v("浏览器想服务器发起第1次请求\n服务器返回第1个结果一个url和状态码302\n然后浏览器发起第2次请求\n使用服务器返回的url、这次请求的范围甚至可以是其余站外的资源\n访问这个url会导致地址栏的url的改变\n然后服务器返回第2个结果到浏览器")]),r._v(" "),e("h3",{attrs:{id:"举例说明-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#举例说明-2"}},[r._v("#")]),r._v(" 举例说明")]),r._v(" "),e("p",[r._v("你来问一个熟人问题（request-1）\n熟人说不会（response-1）让你去度娘问（url）\n你去度娘问网友（调用非熟人的资源、request）\n得到了答案（response）")]),r._v(" "),e("h2",{attrs:{id:"redirect-和-forward的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redirect-和-forward的区别"}},[r._v("#")]),r._v(" redirect 和 forward的区别:")]),r._v(" "),e("ul",[e("li",[r._v("重定向 redirect: 完整的重定向包含两次request-response过程, 第一次是访问原始url, 第二次是服务器通知客户端访问重定向后的url. 重定向完成后, 浏览器的地址是重定向后的url, 而不是原始的url.")])]),r._v(" "),e("p",[r._v("重定向的使用场景: 因为重定向会修改浏览器地址, 所以 form 提交应该使用重定向, 以免用户刷新页面导致form重复提交。")]),r._v(" "),e("p",[r._v("比如我们在逛淘宝，没有登录就点击购买时，会跳转到登录界面，这其实就是一个重定向。本文主要介绍对于后端而言，可以怎样支持302重定向。")]),r._v(" "),e("p",[r._v("转发 forward: 完整的转发仅包含一次 request-response 过程, 用户发出request后, 服务器端视图函数先处理自己的逻辑, 然后在服务器端有调用另一个视图函数, 最后将response返回给浏览器.")]),r._v(" "),e("p",[r._v("请求转发的挑战、为同一业务功能服务\n重定向偏向于、不同业务功能之间的跳转")]),r._v(" "),e("p",[r._v("另外请求转发与重定向明显的一个区别就是：\n如果应该使用重定向的地方、\n使用请求转发会有重复操作的隐患")]),r._v(" "),e("h2",{attrs:{id:"转发和重定向的选择"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#转发和重定向的选择"}},[r._v("#")]),r._v(" 转发和重定向的选择")]),r._v(" "),e("ol",[e("li",[r._v("重定向的速度比转发慢，因为浏览器还得发出一个新的请求，如果在使用转发和重定向都无所谓的时候建议使用转发。")]),r._v(" "),e("li",[r._v("因为转发只能访问当前WEB的应用程序，所以不同WEB应用程序之间的访问，特别是要访问到另外一个WEB站点上的资源的情况，这个时候就只能使用重定向了。")])]),r._v(" "),e("h2",{attrs:{id:"实现方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现方式"}},[r._v("#")]),r._v(" 实现方式")]),r._v(" "),e("h3",{attrs:{id:"转发-forward"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#转发-forward"}},[r._v("#")]),r._v(" 转发 forward")]),r._v(" "),e("p",[r._v("在Spring MVC 中, 构建forward 目标有两种方式:")]),r._v(" "),e("ol",[e("li",[r._v("以字符串的形式构建目标url, url 需要加上 forward: 前缀")]),r._v(" "),e("li",[r._v("使用 ModelAndView 对象来设置转发的forward目标, viewName 可以省略 forward: 前缀, viewName 应该是目标url, 而不是目标视图的函数名.\n传参方式:")]),r._v(" "),e("li",[r._v("以字符串的形式构建目标url, 可以使用 query variable的格式拼url")]),r._v(" "),e("li",[r._v("使用 ModelAndView 对象来增加 attribute Object, 其结果也是在拼接url.\n取参的方式: 可以使用 @RequestParam 来取参.")])]),r._v(" "),e("h3",{attrs:{id:"重定向-redirect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重定向-redirect"}},[r._v("#")]),r._v(" 重定向 redirect")]),r._v(" "),e("p",[r._v("redirect 目标有三种构建方式")]),r._v(" "),e("ol",[e("li",[r._v("使用 redirect: 前缀url方式构建目标url")]),r._v(" "),e("li",[r._v("使用 HttpServletResponse重定向")]),r._v(" "),e("li",[r._v("使用 RedirectView")]),r._v(" "),e("li",[r._v("使用 ModelAndView 类型指定目标, ModelAndView 视图名默认是forward, 所以对于redirect, 需要加上 redirect: 前缀")])]),r._v(" "),e("p",[r._v("传参和取参方式:")]),r._v(" "),e("ol",[e("li",[r._v("传参: 以字符串的形式构建目标url, 可以使用 query variable的格式拼url. 取参: @RequestParam()来fetch")]),r._v(" "),e("li",[r._v("传参: 可以用 HttpServletRequest.getParameterMap()来fetch")]),r._v(" "),e("li",[r._v("传参: redirectAttributes.addAttribute() 加的attr. 取参: @RequestParam()来fetch")]),r._v(" "),e("li",[r._v("传参: redirectAttributes.addFlashAttribute() 加的attr. 取参: @ModelAttribute()来fetch")])]),r._v(" "),e("p",[r._v("Flash attribute的特点:")]),r._v(" "),e("ol",[e("li",[r._v("addFlashAttribute() 可以是任意类型的数据(不局限在String等基本类型), addAttribute()只能加基本类型的参数.")]),r._v(" "),e("li",[r._v("addFlashAttribute() 加的 attr, 不会出现在url 地址栏上.")]),r._v(" "),e("li",[r._v("addFlashAttribute() 加的 attr, 一旦fetch后, 就会自动清空, 非常适合 form 提交后 feedback Message.")])]),r._v(" "),e("h4",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[r._v("#")]),r._v(" 小结")]),r._v(" "),e("p",[r._v("这里主要介绍了两种常见的后端重定向方式，都比较简单，这两种方式也有自己的适用场景（当然并不绝对）")]),r._v(" "),e("ol",[e("li",[r._v("在返回视图的前面加上redirect的方式，更加适用于视图的跳转，从一个网页跳转到另一个网页")]),r._v(" "),e("li",[r._v("HttpServletResponse#sendRedirec的方式更加灵活，可以在后端接收一次http请求生命周期中的任何一个阶段来使用，比如有以下几种常见的场景")])]),r._v(" "),e("ul",[e("li",[r._v("某个接口要求登录时，在拦截器层针对所有未登录的请求，重定向到登录页面")]),r._v(" "),e("li",[r._v("全局异常处理中，如果出现服务器异常，重定向到定制的500页面")]),r._v(" "),e("li",[r._v("不支持的请求，重定向到404页面")])]),r._v(" "),e("h2",{attrs:{id:"项目源码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#项目源码"}},[r._v("#")]),r._v(" 项目源码")]),r._v(" "),e("p",[e("a",{attrs:{href:"https://gitee.com/ClearLove443/spring-boot-demo/tree/master/spring-boot/207-web-response",target:"_blank",rel:"noopener noreferrer"}},[r._v("项目:"),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=v.exports}}]);