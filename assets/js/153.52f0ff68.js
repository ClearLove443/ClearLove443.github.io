(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{724:function(s,a,t){"use strict";t.r(a);var e=t(5),_=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),t("p",[s._v("用python编写好一个工程，在第一次运行后，总会发现工程根目录下生成了一个__pycache__文件夹，里面是和py文件同名的各种 "),t("code",[s._v("*.pyc")]),s._v(" 或者 "),t("code",[s._v("*.pyo")]),s._v(" 文件。")]),s._v(" "),t("p",[s._v("先大概了解一下python基本运行机制。Python程序运行时不需要编译成二进制代码，而直接从源码运行程序，简单来说是，Python解释器将源码转换为字节码，然后再由解释器来执行这些字节码。")]),s._v(" "),t("p",[s._v("解释器的具体工作：")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("完成模块的加载和链接；")])]),s._v(" "),t("li",[t("p",[s._v("将源代码编译为PyCodeObject对象(即字节码)，写入内存中，供CPU读取；")])]),s._v(" "),t("li",[t("p",[s._v("从内存中读取并执行，结束后将PyCodeObject写回硬盘当中，也就是复制到.pyc或.pyo文件中，以保存当前目录下所有脚本的字节码文件；")])]),s._v(" "),t("li",[t("p",[s._v("之后若再次执行该脚本，它先检查【本地是否有上述字节码文件】和【该字节码文件的修改时间是否与其脚本一致】。是就直接执行，否则重复上述步骤。")])])]),s._v(" "),t("p",[s._v("pyc文件的生成是什么情况下生成呢：")]),s._v(" "),t("p",[s._v("python解释器会将 "),t("code",[s._v("*.py")]),s._v(" 脚本文件进行编译，并将编译结果保存到__pycache__目录中。")]),s._v(" "),t("p",[s._v("下次再执行工程时，若解释器发现这个 "),t("code",[s._v("*.py")]),s._v(" 脚本没有修改过，就会跳过编译这一步，直接运行以前生成的保存在 "),t("code",[s._v("__pycache__")]),s._v("文件夹里的"),t("code",[s._v("*.pyc")]),s._v(" 文件。\n这样工程较大时就可以大大缩短项目运行前的准备时间；如果你只需执行一个小工程，没关系 忽略这个文件夹就行。")]),s._v(" "),t("h2",{attrs:{id:"什么时候会出现-pycache-文件夹"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么时候会出现-pycache-文件夹"}},[s._v("#")]),s._v(" 什么时候会出现__pycache__文件夹？")]),s._v(" "),t("p",[s._v('工程目录下有__main__.py文件，和其他将要调用的模块时。如果只有当前运行的脚本 "'),t("strong",[s._v("main")]),s._v('"，则不会生成 '),t("strong",[s._v("pycache")]),s._v(" 的文件。")]),s._v(" "),t("p",[s._v("当 import导入另一个模块的时候会生成\npython3会生成 "),t("strong",[s._v("pycache")])]),s._v(" "),t("h2",{attrs:{id:"如何不生成编译文件呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何不生成编译文件呢"}},[s._v("#")]),s._v(" 如何不生成编译文件呢：")]),s._v(" "),t("ol",[t("li",[s._v("执行的时候 使用 -B参数 即")])]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("python3 -B test.py\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("里面的包含的就不会生成pyc了")]),s._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[s._v("设置环境变量")])]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("export")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("PYTHONDONTWRITEBYTECODE")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("ol",{attrs:{start:"3"}},[t("li",[s._v("在引入的地方写")])]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("import")]),s._v(" sys\nsys.dont_write_bytecode "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" True\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("以上三种方式都可以实现不生成pyc文件。")])])}),[],!1,null,null,null);a.default=_.exports}}]);